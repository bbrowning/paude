#!/bin/bash
set -e

# Version and registry configuration
PAUDE_VERSION="0.3.0"
PAUDE_REGISTRY="${PAUDE_REGISTRY:-docker.io/bbrowning}"

INTERNAL_NETWORK="paude-internal"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Export script dir for library modules (they need to find containers/paude/entrypoint.sh)
PAUDE_SCRIPT_DIR="$SCRIPT_DIR"

# Source library modules
source "$SCRIPT_DIR/lib/config.sh"

# Dev mode: set PAUDE_DEV=1 to build images locally instead of pulling from registry
if [[ "${PAUDE_DEV:-0}" == "1" ]]; then
    DEV_MODE=true
    IMAGE_NAME="paude:latest"
    PROXY_IMAGE="paude-proxy:latest"
else
    DEV_MODE=false
    IMAGE_NAME="$PAUDE_REGISTRY/paude:$PAUDE_VERSION"
    PROXY_IMAGE="$PAUDE_REGISTRY/paude-proxy:$PAUDE_VERSION"
fi

show_help() {
    cat <<'EOF'
paude - Run Claude Code in a secure Podman container

USAGE:
    paude [OPTIONS] [-- CLAUDE_ARGS...]

OPTIONS:
    -h, --help          Show this help message and exit
    -V, --version       Show paude version and exit
    --yolo              Enable YOLO mode (skip all permission prompts)
                        Claude can edit files and run commands without confirmation
    --allow-network     Allow unrestricted network access
                        By default, network is restricted to Vertex AI endpoints only
    --rebuild           Force rebuild of workspace container image
                        Use when devcontainer.json has changed
    --dry-run           Show configuration and what would be done, then exit
                        Useful for verifying paude.json or devcontainer.json

CLAUDE OPTIONS:
    All arguments after -- are passed directly to claude.
    Run 'paude -- --help' to see claude's options.

EXAMPLES:
    paude                           Start interactive claude session
    paude --yolo                    Start with YOLO mode (no permission prompts)
    paude -- -p "What is 2+2?"      Run claude with a prompt
    paude --yolo -- -p "Fix bugs"   YOLO mode with a prompt
    paude -- --help                 Show claude's help

SECURITY:
    By default, paude runs with network restricted to Google/Anthropic APIs only.
    Use --allow-network to permit all network access (enables data exfiltration).
    Combining --yolo with --allow-network is maximum risk mode.

EOF
}

show_version() {
    echo "paude $PAUDE_VERSION"
    if [[ "$DEV_MODE" == "true" ]]; then
        echo "  mode: development (PAUDE_DEV=1, building locally)"
    else
        echo "  mode: installed (pulling from $PAUDE_REGISTRY)"
    fi
}

show_dry_run() {
    echo "=== Paude Dry Run ==="
    echo ""
    echo "Workspace: $WORKSPACE_DIR"
    echo ""

    if [[ -n "$PAUDE_CONFIG_FILE" ]]; then
        echo "Configuration:"
        echo "  File: $PAUDE_CONFIG_FILE"
        echo "  Type: $PAUDE_CONFIG_TYPE"
        echo ""
    else
        echo "Configuration: none (using default paude image)"
        echo ""
    fi

    if [[ -n "$PAUDE_BASE_IMAGE" ]]; then
        echo "Base image: $PAUDE_BASE_IMAGE"
    elif [[ -n "$PAUDE_DOCKERFILE" ]]; then
        echo "Dockerfile: $PAUDE_DOCKERFILE"
        if [[ -n "$PAUDE_BUILD_CONTEXT" ]]; then
            echo "Build context: $PAUDE_BUILD_CONTEXT"
        fi
    else
        echo "Image: $IMAGE_NAME (default)"
    fi
    echo ""

    if [[ ${#PAUDE_PACKAGES[@]} -gt 0 ]]; then
        echo "Additional packages:"
        for pkg in "${PAUDE_PACKAGES[@]}"; do
            echo "  - $pkg"
        done
        echo ""
    fi

    if [[ -n "$PAUDE_POST_CREATE_COMMAND" ]]; then
        echo "Setup command: $PAUDE_POST_CREATE_COMMAND"
        echo ""
    fi

    if needs_custom_build; then
        # Source hash module to show what the image tag would be
        source "$SCRIPT_DIR/lib/hash.sh"
        local config_hash
        config_hash=$(compute_config_hash)
        local custom_image="paude-workspace:$config_hash"

        echo "Would build: $custom_image"
        if podman image exists "$custom_image" 2>/dev/null; then
            echo "  (image already cached)"
        else
            echo "  (image would be built)"
        fi
        echo ""

        echo "Generated Dockerfile:"
        echo "---"
        generate_workspace_dockerfile "$PAUDE_BASE_IMAGE"
        echo "---"
    fi

    echo ""
    echo "Flags:"
    echo "  --yolo: $YOLO_MODE"
    echo "  --allow-network: $ALLOW_NETWORK"
    echo "  --rebuild: $FORCE_REBUILD"
}

# Parse paude-specific flags before -- separator
ALLOW_NETWORK=false
YOLO_MODE=false
FORCE_REBUILD=false
DRY_RUN=false
CLAUDE_ARGS=()
PARSING_PAUDE_ARGS=true

for arg in "$@"; do
    if [[ "$PARSING_PAUDE_ARGS" == "true" ]]; then
        case "$arg" in
            --)
                PARSING_PAUDE_ARGS=false
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            -V|--version)
                show_version
                exit 0
                ;;
            --allow-network)
                ALLOW_NETWORK=true
                ;;
            --yolo)
                YOLO_MODE=true
                ;;
            --rebuild)
                FORCE_REBUILD=true
                ;;
            --dry-run)
                DRY_RUN=true
                ;;
            *)
                # Unknown paude option - could be claude arg without --
                # For backwards compatibility, pass through to claude
                CLAUDE_ARGS+=("$arg")
                ;;
        esac
    else
        CLAUDE_ARGS+=("$arg")
    fi
done

resolve_path() {
    local path="$1"
    if [[ -e "$path" ]]; then
        cd -P "$(dirname "$path")" 2>/dev/null && echo "$(pwd -P)/$(basename "$path")"
    fi
}

show_macos_volume_help() {
    local volume_path
    volume_path=$(echo "$WORKSPACE_DIR" | cut -d'/' -f1-3)

    echo "" >&2
    echo "Podman on macOS only mounts /Users by default." >&2
    echo "To use paths under $volume_path, recreate your Podman machine with:" >&2
    echo "" >&2
    echo "  podman machine stop" >&2
    echo "  podman machine rm" >&2
    echo "  podman machine init \\" >&2
    echo "    --volume /Users:/Users \\" >&2
    echo "    --volume /private:/private \\" >&2
    echo "    --volume /var/folders:/var/folders \\" >&2
    echo "    --volume $volume_path:$volume_path" >&2
    echo "  podman machine start" >&2
    echo "" >&2
    echo "Note: This will remove your existing Podman machine. Container images" >&2
    echo "will need to be rebuilt/pulled after recreating the machine." >&2
}

check_requirements() {
    if ! command -v podman &> /dev/null; then
        echo "Error: podman is not installed or not in PATH" >&2
        echo "Please install podman: https://podman.io/getting-started/installation" >&2
        exit 1
    fi
}

prepare_build_dir() {
    PAUDE_BUILD_DIR="${TMPDIR:-/tmp}/paude-build-$$"
    mkdir -p "$PAUDE_BUILD_DIR"
    # Copy entrypoint to build context
    cp "$SCRIPT_DIR/containers/paude/entrypoint.sh" "$PAUDE_BUILD_DIR/"
}

cleanup_build_dir() {
    if [[ -n "$PAUDE_BUILD_DIR" && -d "$PAUDE_BUILD_DIR" ]]; then
        rm -rf "$PAUDE_BUILD_DIR"
    fi
}

ensure_images() {
    if needs_custom_build; then
        ensure_custom_image
    else
        ensure_default_image
    fi

    # Proxy image logic remains the same
    if [[ "$ALLOW_NETWORK" == "false" ]]; then
        ensure_proxy_image
    fi
}

ensure_default_image() {
    if [[ "$DEV_MODE" == "true" ]]; then
        if ! podman image exists "$IMAGE_NAME" 2>/dev/null; then
            echo "Building $IMAGE_NAME image..."
            if ! podman build -t "$IMAGE_NAME" "$SCRIPT_DIR/containers/paude"; then
                echo "Error: Failed to build $IMAGE_NAME" >&2
                exit 1
            fi
        fi
    else
        if ! podman image exists "$IMAGE_NAME" 2>/dev/null; then
            echo "Pulling $IMAGE_NAME..."
            if ! podman pull "$IMAGE_NAME"; then
                echo "Error: Failed to pull $IMAGE_NAME" >&2
                exit 1
            fi
        fi
    fi
}

ensure_custom_image() {
    # Source hash module
    source "$SCRIPT_DIR/lib/hash.sh"
    source "$SCRIPT_DIR/lib/features.sh"

    local config_hash
    config_hash=$(compute_config_hash)
    local custom_image="paude-workspace:$config_hash"

    # Check if image already exists and rebuild not forced
    if podman image exists "$custom_image" 2>/dev/null && [[ "$FORCE_REBUILD" != "true" ]]; then
        echo "Using cached workspace image: $custom_image" >&2
        IMAGE_NAME="$custom_image"
        return 0
    fi

    echo "Building workspace image..." >&2
    prepare_build_dir
    trap cleanup_build_dir EXIT

    # Parse features
    parse_features

    if [[ -n "$PAUDE_BASE_IMAGE" ]]; then
        # Generate Dockerfile for image-based config
        generate_workspace_dockerfile "$PAUDE_BASE_IMAGE" "$PAUDE_BUILD_DIR" > "$PAUDE_BUILD_DIR/Dockerfile"

        # Add feature installations before USER directive if we have features
        if has_features; then
            local features_block
            features_block=$(generate_features_dockerfile)
            if [[ -n "$features_block" ]]; then
                # Insert features before "USER paude" line using a temp file
                local tmp_dockerfile="$PAUDE_BUILD_DIR/Dockerfile.tmp"
                awk -v features="$features_block" '/^USER paude$/{print features}1' "$PAUDE_BUILD_DIR/Dockerfile" > "$tmp_dockerfile"
                mv "$tmp_dockerfile" "$PAUDE_BUILD_DIR/Dockerfile"
                # Copy features to build context
                if [[ -d "$FEATURE_CACHE_DIR" ]]; then
                    cp -r "$FEATURE_CACHE_DIR" "$PAUDE_BUILD_DIR/features"
                fi
            fi
        fi

        echo "  → Using base: $PAUDE_BASE_IMAGE" >&2
        if ! podman build \
            --build-arg "BASE_IMAGE=$PAUDE_BASE_IMAGE" \
            -t "$custom_image" \
            "$PAUDE_BUILD_DIR"; then
            echo "Error: Failed to build workspace image" >&2
            exit 1
        fi
    elif [[ -n "$PAUDE_DOCKERFILE" ]]; then
        if [[ ! -f "$PAUDE_DOCKERFILE" ]]; then
            echo "Error: Dockerfile not found: $PAUDE_DOCKERFILE" >&2
            exit 1
        fi

        echo "  → Building from: $PAUDE_DOCKERFILE" >&2

        # Build user's image first
        local user_image="paude-user-base:$config_hash"
        local build_context="${PAUDE_BUILD_CONTEXT:-$(dirname "$PAUDE_DOCKERFILE")}"
        local build_args
        build_args=$(parse_build_args)

        echo "  → Building user Dockerfile..." >&2
        if ! podman build \
            -t "$user_image" \
            -f "$PAUDE_DOCKERFILE" \
            $build_args \
            "$build_context"; then
            echo "Error: Failed to build user Dockerfile" >&2
            exit 1
        fi

        # Now generate and build paude wrapper
        generate_workspace_dockerfile "$user_image" "$PAUDE_BUILD_DIR" > "$PAUDE_BUILD_DIR/Dockerfile"

        # Add feature installations if we have features
        if has_features; then
            local features_block
            features_block=$(generate_features_dockerfile)
            if [[ -n "$features_block" ]]; then
                local tmp_dockerfile="$PAUDE_BUILD_DIR/Dockerfile.tmp"
                awk -v features="$features_block" '/^USER paude$/{print features}1' "$PAUDE_BUILD_DIR/Dockerfile" > "$tmp_dockerfile"
                mv "$tmp_dockerfile" "$PAUDE_BUILD_DIR/Dockerfile"
                if [[ -d "$FEATURE_CACHE_DIR" ]]; then
                    cp -r "$FEATURE_CACHE_DIR" "$PAUDE_BUILD_DIR/features"
                fi
            fi
        fi

        echo "  → Adding paude requirements..." >&2
        if ! podman build \
            --build-arg "BASE_IMAGE=$user_image" \
            -t "$custom_image" \
            "$PAUDE_BUILD_DIR"; then
            echo "Error: Failed to build workspace image" >&2
            exit 1
        fi
    fi

    echo "Build complete (cached as $custom_image)" >&2
    IMAGE_NAME="$custom_image"
}

ensure_proxy_image() {
    if [[ "$DEV_MODE" == "true" ]]; then
        if ! podman image exists "$PROXY_IMAGE" 2>/dev/null; then
            echo "Building $PROXY_IMAGE image..."
            if ! podman build -t "$PROXY_IMAGE" "$SCRIPT_DIR/containers/proxy"; then
                echo "Error: Failed to build $PROXY_IMAGE" >&2
                exit 1
            fi
        fi
    else
        if ! podman image exists "$PROXY_IMAGE" 2>/dev/null; then
            echo "Pulling $PROXY_IMAGE..."
            if ! podman pull "$PROXY_IMAGE"; then
                echo "Error: Failed to pull $PROXY_IMAGE" >&2
                echo "Check your network connection or run 'podman login' if authentication is required." >&2
                exit 1
            fi
        fi
    fi
}

setup_environment() {
    ENV_ARGS=()
    for var in CLAUDE_CODE_USE_VERTEX ANTHROPIC_VERTEX_PROJECT_ID GOOGLE_CLOUD_PROJECT; do
        if [[ -n "${!var}" ]]; then
            ENV_ARGS+=(-e "$var=${!var}")
        fi
    done

    for var in $(compgen -v | grep '^CLOUDSDK_AUTH'); do
        ENV_ARGS+=(-e "$var=${!var}")
    done
}

setup_mounts() {
    # WORKSPACE_DIR is set early in main execution for config detection

    MOUNT_ARGS=(
        -v "$WORKSPACE_DIR:$WORKSPACE_DIR:rw"
    )

    GCLOUD_DIR="$(resolve_path "$HOME/.config/gcloud")"
    if [[ -n "$GCLOUD_DIR" && -d "$GCLOUD_DIR" ]]; then
        MOUNT_ARGS+=(-v "$GCLOUD_DIR:/home/paude/.config/gcloud:ro")
    fi

    if [[ -d "$HOME/.claude" ]]; then
        CLAUDE_DIR="$(resolve_path "$HOME/.claude")"
        if [[ -n "$CLAUDE_DIR" && -d "$CLAUDE_DIR" ]]; then
            MOUNT_ARGS+=(-v "$CLAUDE_DIR:/tmp/claude.seed:ro")
            # Mount plugins at original host path for hardcoded plugin references
            if [[ -d "$CLAUDE_DIR/plugins" ]]; then
                MOUNT_ARGS+=(-v "$CLAUDE_DIR/plugins:$CLAUDE_DIR/plugins:ro")
            fi
        fi
    fi

    GITCONFIG="$(resolve_path "$HOME/.gitconfig")"
    if [[ -n "$GITCONFIG" && -f "$GITCONFIG" ]]; then
        MOUNT_ARGS+=(-v "$GITCONFIG:/home/paude/.gitconfig:ro")
    fi

    if [[ -f "$HOME/.claude.json" ]]; then
        CLAUDE_JSON="$(resolve_path "$HOME/.claude.json")"
        if [[ -n "$CLAUDE_JSON" && -f "$CLAUDE_JSON" ]]; then
            MOUNT_ARGS+=(-v "$CLAUDE_JSON:/tmp/claude.json.seed:ro")
        fi
    fi
}

check_macos_volumes() {
    if [[ "$(uname)" == "Darwin" && ! "$WORKSPACE_DIR" =~ ^/Users/ ]]; then
        test_output=$(podman run --rm \
            -v "$WORKSPACE_DIR:$WORKSPACE_DIR:rw" \
            "$IMAGE_NAME" \
            --version 2>&1) || {
            echo "$test_output" >&2
            show_macos_volume_help
            exit 1
        }
    fi
}

check_git_safety() {
    if [[ ! -d "$WORKSPACE_DIR/.git" ]]; then
        echo "Warning: No git repository in workspace." >&2
        echo "  Without git, deleted/modified files cannot be recovered." >&2
        echo "  Consider: git init && git add -A && git commit -m 'Initial commit'" >&2
        echo "" >&2
        return
    fi

    local remotes
    remotes=$(git -C "$WORKSPACE_DIR" remote 2>/dev/null)
    if [[ -z "$remotes" ]]; then
        echo "Warning: Git repository has no remotes configured." >&2
        echo "  Without a remote, your work has no off-machine backup." >&2
        echo "  Consider: git remote add origin <url> && git push -u origin main" >&2
        echo "" >&2
    fi
}

setup_proxy() {
    if ! podman network exists "$INTERNAL_NETWORK" 2>/dev/null; then
        echo "Creating $INTERNAL_NETWORK network..."
        podman network create --internal "$INTERNAL_NETWORK"
    fi

    SESSION_ID=$(date +%s)-$$
    PROXY_NAME="paude-proxy-$SESSION_ID"

    cleanup() {
        podman kill "$PROXY_NAME" >/dev/null 2>&1 || true
    }
    trap cleanup EXIT INT TERM

    # Get DNS from podman machine (works on macOS where containers run in a VM)
    local dns_env=()
    if podman machine inspect &>/dev/null; then
        local vm_dns
        vm_dns=$(podman machine ssh grep nameserver /etc/resolv.conf 2>/dev/null | awk '{print $2}' | head -1)
        if [[ -n "$vm_dns" ]]; then
            dns_env=(-e "SQUID_DNS=$vm_dns")
        fi
    fi

    podman run -d --rm --name "$PROXY_NAME" \
        --network "$INTERNAL_NETWORK,podman" \
        "${dns_env[@]}" \
        "$PROXY_IMAGE" >/dev/null

    sleep 1
}

run_claude() {
    local network_args=()
    local proxy_env=()

    if [[ "$YOLO_MODE" == "true" && "$ALLOW_NETWORK" == "true" ]]; then
        echo "" >&2
        echo "╔══════════════════════════════════════════════════════════════════╗" >&2
        echo "║  WARNING: MAXIMUM RISK MODE                                      ║" >&2
        echo "║                                                                  ║" >&2
        echo "║  --yolo + --allow-network = Claude can exfiltrate any file      ║" >&2
        echo "║  to the internet without confirmation. Only use if you trust    ║" >&2
        echo "║  the task completely.                                           ║" >&2
        echo "╚══════════════════════════════════════════════════════════════════╝" >&2
        echo "" >&2
        CLAUDE_ARGS=("--dangerously-skip-permissions" "${CLAUDE_ARGS[@]}")
    elif [[ "$YOLO_MODE" == "true" ]]; then
        echo "Warning: YOLO mode enabled. Claude can edit files and run commands without confirmation." >&2
        CLAUDE_ARGS=("--dangerously-skip-permissions" "${CLAUDE_ARGS[@]}")
    elif [[ "$ALLOW_NETWORK" == "true" ]]; then
        echo "Warning: Network access enabled. Data exfiltration is possible." >&2
    fi

    if [[ "$ALLOW_NETWORK" == "true" ]]; then
        :  # No proxy setup needed
    else
        network_args=(--network "$INTERNAL_NETWORK")
        proxy_env=(
            -e "HTTPS_PROXY=http://$PROXY_NAME:3128"
            -e "HTTP_PROXY=http://$PROXY_NAME:3128"
            -e "https_proxy=http://$PROXY_NAME:3128"
            -e "http_proxy=http://$PROXY_NAME:3128"
        )
    fi

    # Parse container env from config
    parse_container_env

    # Parse post-create command from config
    parse_post_create_command

    # Check if postCreateCommand needs to run
    local workspace_marker="$WORKSPACE_DIR/.paude-initialized"

    if [[ -n "$PAUDE_POST_CREATE_COMMAND" && ! -f "$workspace_marker" ]]; then
        echo "Running postCreateCommand: $PAUDE_POST_CREATE_COMMAND" >&2

        if ! podman run --rm \
            -w "$WORKSPACE_DIR" \
            "${network_args[@]}" \
            "${proxy_env[@]}" \
            "${ENV_ARGS[@]}" \
            "${PAUDE_CONTAINER_ENV[@]}" \
            "${MOUNT_ARGS[@]}" \
            "$IMAGE_NAME" \
            /bin/bash -c "$PAUDE_POST_CREATE_COMMAND"; then
            echo "Warning: postCreateCommand failed" >&2
        else
            # Mark as initialized only on success
            touch "$workspace_marker"
        fi
    fi

    podman run --rm -it \
        -w "$WORKSPACE_DIR" \
        "${network_args[@]}" \
        "${proxy_env[@]}" \
        "${ENV_ARGS[@]}" \
        "${PAUDE_CONTAINER_ENV[@]}" \
        "${MOUNT_ARGS[@]}" \
        "$IMAGE_NAME" \
        "${CLAUDE_ARGS[@]}"
}

# Main execution

# Setup workspace dir early (needed for config detection)
WORKSPACE_DIR="$(pwd -P)"

# Detect and parse configuration
detect_config "$WORKSPACE_DIR"
if has_custom_config; then
    parse_config || exit 1
fi

# Handle dry-run mode (doesn't require podman)
if [[ "$DRY_RUN" == "true" ]]; then
    show_dry_run
    exit 0
fi

check_requirements
ensure_images
setup_environment
setup_mounts
check_macos_volumes
check_git_safety

if [[ "$ALLOW_NETWORK" == "false" ]]; then
    setup_proxy
fi

run_claude
