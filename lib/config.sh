#!/bin/bash
# lib/config.sh - Configuration detection and parsing for BYOC

# === Global Variables (initialize at top of file) ===
PAUDE_CONFIG_FILE=""
PAUDE_CONFIG_TYPE="default"
PAUDE_BASE_IMAGE=""
PAUDE_DOCKERFILE=""
PAUDE_BUILD_CONTEXT=""

# Set by parse_features (Task 2.1):
PAUDE_FEATURES=()

# Set by parse_post_create_command (Task 3.1):
PAUDE_POST_CREATE_COMMAND=""

# Set by parse_container_env (Task 3.2):
PAUDE_CONTAINER_ENV=()

# Set by _parse_paude_json (Task 4.1):
PAUDE_PACKAGES=()
PAUDE_SETUP_COMMAND=""

# === Functions ===

detect_config() {
    # Check locations in priority order
    local workspace="${1:-$(pwd)}"

    PAUDE_CONFIG_FILE=""
    PAUDE_CONFIG_TYPE="default"

    if [[ -f "$workspace/.devcontainer/devcontainer.json" ]]; then
        PAUDE_CONFIG_FILE="$workspace/.devcontainer/devcontainer.json"
        PAUDE_CONFIG_TYPE="devcontainer"
    elif [[ -f "$workspace/.devcontainer.json" ]]; then
        PAUDE_CONFIG_FILE="$workspace/.devcontainer.json"
        PAUDE_CONFIG_TYPE="devcontainer"
    elif [[ -f "$workspace/paude.json" ]]; then
        PAUDE_CONFIG_FILE="$workspace/paude.json"
        PAUDE_CONFIG_TYPE="paude"
    fi

    if [[ -n "$PAUDE_CONFIG_FILE" ]]; then
        echo "Detected $PAUDE_CONFIG_TYPE config: $PAUDE_CONFIG_FILE" >&2
    fi
}

parse_config() {
    # Call after detect_config(). Parses the config file and sets global variables.
    # Returns 0 on success, 1 on error.

    if [[ -z "$PAUDE_CONFIG_FILE" ]]; then
        # No config, use defaults
        PAUDE_BASE_IMAGE=""
        PAUDE_DOCKERFILE=""
        PAUDE_BUILD_CONTEXT=""
        return 0
    fi

    # Validate JSON
    if ! jq empty "$PAUDE_CONFIG_FILE" 2>/dev/null; then
        echo "Error: Invalid JSON in $PAUDE_CONFIG_FILE" >&2
        return 1
    fi

    if [[ "$PAUDE_CONFIG_TYPE" == "devcontainer" ]]; then
        _parse_devcontainer
    elif [[ "$PAUDE_CONFIG_TYPE" == "paude" ]]; then
        _parse_paude_json
    fi
}

_parse_devcontainer() {
    local config_dir
    config_dir=$(dirname "$PAUDE_CONFIG_FILE")

    # Extract image (direct image reference)
    PAUDE_BASE_IMAGE=$(jq -r '.image // empty' "$PAUDE_CONFIG_FILE")

    # Extract dockerfile path (for custom builds)
    PAUDE_DOCKERFILE=$(jq -r '.build.dockerfile // empty' "$PAUDE_CONFIG_FILE")
    if [[ -n "$PAUDE_DOCKERFILE" ]]; then
        # Make path absolute relative to config file location
        if [[ ! "$PAUDE_DOCKERFILE" = /* ]]; then
            PAUDE_DOCKERFILE="$config_dir/$PAUDE_DOCKERFILE"
        fi
    fi

    # Extract build context
    PAUDE_BUILD_CONTEXT=$(jq -r '.build.context // empty' "$PAUDE_CONFIG_FILE")
    if [[ -n "$PAUDE_BUILD_CONTEXT" ]]; then
        if [[ ! "$PAUDE_BUILD_CONTEXT" = /* ]]; then
            PAUDE_BUILD_CONTEXT="$config_dir/$PAUDE_BUILD_CONTEXT"
        fi
        # Normalize the path (resolve ..)
        if [[ -d "$PAUDE_BUILD_CONTEXT" ]]; then
            PAUDE_BUILD_CONTEXT=$(cd "$PAUDE_BUILD_CONTEXT" && pwd -P)
        fi
    elif [[ -n "$PAUDE_DOCKERFILE" ]]; then
        # Default context is the directory containing devcontainer.json
        PAUDE_BUILD_CONTEXT="$config_dir"
    fi

    # Warn about unsupported properties
    _warn_unsupported_properties
}

_parse_paude_json() {
    # paude.json format:
    # {
    #   "base": "python:3.11-slim",
    #   "packages": ["git", "make", "gcc"],
    #   "setup": "pip install -r requirements.txt"
    # }

    PAUDE_BASE_IMAGE=$(jq -r '.base // empty' "$PAUDE_CONFIG_FILE")
    PAUDE_DOCKERFILE=""
    PAUDE_BUILD_CONTEXT=""

    # Parse packages array
    PAUDE_PACKAGES=()
    while IFS= read -r pkg; do
        if [[ -n "$pkg" ]]; then
            PAUDE_PACKAGES+=("$pkg")
        fi
    done < <(jq -r '.packages[]? // empty' "$PAUDE_CONFIG_FILE")

    # Parse setup command (maps to postCreateCommand)
    PAUDE_SETUP_COMMAND=$(jq -r '.setup // empty' "$PAUDE_CONFIG_FILE")
    if [[ -n "$PAUDE_SETUP_COMMAND" ]]; then
        PAUDE_POST_CREATE_COMMAND="$PAUDE_SETUP_COMMAND"
    fi
}

_warn_unsupported_properties() {
    local unsupported=("mounts" "runArgs" "privileged" "capAdd" "forwardPorts" "remoteUser")
    for prop in "${unsupported[@]}"; do
        if jq -e ".$prop" "$PAUDE_CONFIG_FILE" >/dev/null 2>&1; then
            echo "Warning: Ignoring unsupported property '$prop' in config" >&2
            echo "  â†’ paude controls this for security" >&2
        fi
    done
}

has_custom_config() {
    # Returns 0 if custom config exists, 1 otherwise
    [[ -n "$PAUDE_CONFIG_FILE" ]]
}

needs_custom_build() {
    # Returns 0 if we need to build a custom image, 1 otherwise
    [[ -n "$PAUDE_BASE_IMAGE" || -n "$PAUDE_DOCKERFILE" ]]
}

generate_workspace_dockerfile() {
    # Generates a Dockerfile that wraps the user's base image with paude requirements
    # Output: writes Dockerfile content to stdout
    local base_image="$1"

    cat <<'DOCKERFILE_HEADER'
# Auto-generated by paude - DO NOT EDIT
ARG BASE_IMAGE
FROM ${BASE_IMAGE}
DOCKERFILE_HEADER

    # Add user-specified packages if any (from paude.json "packages" array)
    if [[ ${#PAUDE_PACKAGES[@]} -gt 0 ]]; then
        local pkg_list="${PAUDE_PACKAGES[*]}"
        cat <<PACKAGES

# User-specified packages from paude.json
RUN if command -v apt-get >/dev/null 2>&1; then \\
        apt-get update && apt-get install -y $pkg_list && rm -rf /var/lib/apt/lists/*; \\
    elif command -v apk >/dev/null 2>&1; then \\
        apk add --no-cache $pkg_list; \\
    elif command -v yum >/dev/null 2>&1; then \\
        yum install -y $pkg_list && yum clean all; \\
    fi
PACKAGES
    fi

    # Standard paude requirements
    cat <<'DOCKERFILE_BODY'

# Install required system packages
RUN if command -v apt-get >/dev/null 2>&1; then \
        apt-get update && \
        apt-get install -y --no-install-recommends git curl ca-certificates && \
        rm -rf /var/lib/apt/lists/*; \
    elif command -v apk >/dev/null 2>&1; then \
        apk add --no-cache git curl ca-certificates; \
    elif command -v yum >/dev/null 2>&1; then \
        yum install -y git curl ca-certificates && \
        yum clean all; \
    else \
        echo "Warning: Unknown package manager, git may not be available" >&2; \
    fi

# Install Node.js if not present (required for claude-code)
RUN if ! command -v node >/dev/null 2>&1; then \
        if command -v apt-get >/dev/null 2>&1; then \
            curl -fsSL https://deb.nodesource.com/setup_22.x | bash - && \
            apt-get install -y nodejs && \
            rm -rf /var/lib/apt/lists/*; \
        elif command -v apk >/dev/null 2>&1; then \
            apk add --no-cache nodejs npm; \
        else \
            echo "Error: Cannot install Node.js - unsupported base image" >&2 && exit 1; \
        fi \
    fi

# Install Claude Code
RUN npm install -g @anthropic-ai/claude-code

# Create paude user if it doesn't exist
RUN id paude >/dev/null 2>&1 || useradd -m -s /bin/bash paude 2>/dev/null || adduser -D -s /bin/bash paude

# Copy entrypoint
COPY entrypoint.sh /usr/local/bin/entrypoint.sh
RUN chmod +x /usr/local/bin/entrypoint.sh

USER paude
ENTRYPOINT ["/usr/local/bin/entrypoint.sh"]
DOCKERFILE_BODY
}

parse_build_args() {
    # Returns build args as "--build-arg KEY=VALUE" strings
    # Usage: build_args=$(parse_build_args)
    if [[ -z "$PAUDE_CONFIG_FILE" ]]; then
        return
    fi

    jq -r '.build.args // {} | to_entries[] | "--build-arg \(.key)=\(.value)"' "$PAUDE_CONFIG_FILE" 2>/dev/null || true
}

parse_features() {
    # Parse features from devcontainer.json into PAUDE_FEATURES array
    # Each element is "feature_url|options_json"

    PAUDE_FEATURES=()

    if [[ -z "$PAUDE_CONFIG_FILE" ]]; then
        return 0
    fi

    # Check if features exist
    if ! jq -e '.features' "$PAUDE_CONFIG_FILE" >/dev/null 2>&1; then
        return 0
    fi

    # Extract features as "url|options" pairs
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            PAUDE_FEATURES+=("$line")
        fi
    done < <(jq -r '.features | to_entries[] | "\(.key)|\(.value | @json)"' "$PAUDE_CONFIG_FILE")

    echo "Found ${#PAUDE_FEATURES[@]} feature(s)" >&2
}

has_features() {
    [[ ${#PAUDE_FEATURES[@]} -gt 0 ]]
}

parse_post_create_command() {
    if [[ -z "$PAUDE_CONFIG_FILE" ]]; then
        return 0
    fi

    # postCreateCommand can be string or array
    local cmd
    cmd=$(jq -r 'if .postCreateCommand | type == "array" then .postCreateCommand | join(" && ") else .postCreateCommand // empty end' "$PAUDE_CONFIG_FILE")

    PAUDE_POST_CREATE_COMMAND="$cmd"
}

parse_container_env() {
    PAUDE_CONTAINER_ENV=()

    if [[ -z "$PAUDE_CONFIG_FILE" ]]; then
        return 0
    fi

    # Extract containerEnv as array of -e KEY=VALUE
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            PAUDE_CONTAINER_ENV+=("-e" "$line")
        fi
    done < <(jq -r '.containerEnv // {} | to_entries[] | "\(.key)=\(.value)"' "$PAUDE_CONFIG_FILE")
}
